import e from"debug";import t from"xml-js";var r;!function(e){e.CALENDAR_SERVER="http://calendarserver.org/ns/",e.CALDAV_APPLE="http://apple.com/ns/ical/",e.CALDAV="urn:ietf:params:xml:ns:caldav",e.CARDDAV="urn:ietf:params:xml:ns:carddav",e.DAV="DAV:"}(r||(r={}));const a={[r.CALDAV]:"xmlns:c",[r.CARDDAV]:"xmlns:card",[r.CALENDAR_SERVER]:"xmlns:cs",[r.CALDAV_APPLE]:"xmlns:ca",[r.DAV]:"xmlns:d"};var s,o;!function(e){e.CALDAV="c",e.CARDDAV="card",e.CALENDAR_SERVER="cs",e.CALDAV_APPLE="ca",e.DAV="d"}(s||(s={})),function(e){e.VEVENT="VEVENT",e.VTODO="VTODO",e.VJOURNAL="VJOURNAL",e.VFREEBUSY="VFREEBUSY",e.VTIMEZONE="VTIMEZONE",e.VALARM="VALARM"}(o||(o={}));const n=e=>{const t=Number(e);if(!Number.isNaN(t))return t;const r=e.toLowerCase();return"true"===r||"false"!==r&&e},c=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim();if(Math.abs(r.length-a.length)>1)return!1;const s="/"===r.slice(-1)?r.slice(0,-1):r,o="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(o)||t.includes(s)},d=(e,t)=>{if(!e&&!t)return!0;if(!e||!t)return!1;const r=e.trim(),a=t.trim(),s="/"===r.slice(-1)?r.slice(0,-1):r,o="/"===a.slice(-1)?a.slice(0,-1):a;return e.includes(o)||t.includes(s)},i=e=>e.reduce(((e,t)=>({...e,[a[t]]:t})),{}),l=e=>Object.entries(e).reduce(((e,[t,r])=>r?{...e,[t]:r}:e),{}),u=(e,t)=>t?{[e]:t}:{},h=(e,t)=>e?t&&0!==t.length?Object.fromEntries(Object.entries(e).filter((([e])=>!t.includes(e)))):e:{};var p=Object.freeze({__proto__:null,cleanupFalsy:l,conditionalParam:u,excludeHeaders:h,getDAVAttribute:i,urlContains:d,urlEquals:c});const f=e("tsdav:request"),v=async e=>{var r;const{url:a,init:s,convertIncoming:o=!0,parseOutgoing:c=!0,fetchOptions:d={}}=e,{headers:i={},body:u,namespace:h,method:p,attributes:v}=s,y=o?t.js2xml({_declaration:{_attributes:{version:"1.0",encoding:"utf-8"}},...u,_attributes:v},{compact:!0,spaces:2,elementNameFn:e=>h&&!/^.+:.+/.test(e)?`${h}:${e}`:e}):u,O={...d};delete O.headers;const m=await fetch(a,{headers:{"Content-Type":"text/xml;charset=UTF-8",...l(i),...d.headers},body:y,method:p,...O}),A=await m.text();if(!m.ok||!(null===(r=m.headers.get("content-type"))||void 0===r?void 0:r.includes("xml"))||!c)return[{href:m.url,ok:m.ok,status:m.status,statusText:m.statusText,raw:A}];const g=t.xml2js(A,{compact:!0,trim:!0,textFn:(e,t)=>{try{const r=t._parent,a=Object.keys(r),s=a[a.length-1],o=r[s];if(o.length>0){o[o.length-1]=n(e)}else r[s]=n(e)}catch(e){f(e.stack)}},elementNameFn:e=>e.replace(/^.+:/,"").replace(/([-_]\w)/g,(e=>e[1].toUpperCase())),attributesFn:e=>{const t={...e};return delete t.xmlns,t},ignoreDeclaration:!0});return(Array.isArray(g.multistatus.response)?g.multistatus.response:[g.multistatus.response]).map((e=>{var t,r;if(!e)return{status:m.status,statusText:m.statusText,ok:m.ok};const a=/^\S+\s(?<status>\d+)\s(?<statusText>.+)$/.exec(e.status);return{raw:g,href:e.href,status:(null==a?void 0:a.groups)?Number.parseInt(null==a?void 0:a.groups.status,10):m.status,statusText:null!==(r=null===(t=null==a?void 0:a.groups)||void 0===t?void 0:t.statusText)&&void 0!==r?r:m.statusText,ok:!e.error,error:e.error,responsedescription:e.responsedescription,props:(Array.isArray(e.propstat)?e.propstat:[e.propstat]).reduce(((e,t)=>({...e,...null==t?void 0:t.prop})),{})}}))},y=async e=>{const{url:t,props:a,depth:o,headers:n,headersToExclude:c,fetchOptions:d={}}=e;return v({url:t,init:{method:"PROPFIND",headers:h(l({depth:o,...n}),c),namespace:s.DAV,body:{propfind:{_attributes:i([r.CALDAV,r.CALDAV_APPLE,r.CALENDAR_SERVER,r.CARDDAV,r.DAV]),prop:a}}},fetchOptions:d})},O=async e=>{const{url:t,data:r,headers:a,headersToExclude:s,fetchOptions:o={}}=e,n={...o};return delete n.headers,fetch(t,{method:"PUT",body:r,headers:{...h(a,s),...o.headers},...n})},m=async e=>{const{url:t,data:r,etag:a,headers:s,headersToExclude:o,fetchOptions:n={}}=e,c={...n};return delete c.headers,fetch(t,{method:"PUT",body:r,headers:{...h(l({"If-Match":a,...s}),o),...n.headers},...c})},A=async e=>{const{url:t,headers:r,etag:a,headersToExclude:s,fetchOptions:o={}}=e,n={...o};return delete n.headers,fetch(t,{method:"DELETE",headers:{...h(l({"If-Match":a,...r}),s),...o.headers},...n})};var g=Object.freeze({__proto__:null,createObject:O,davRequest:v,deleteObject:A,propfind:y,updateObject:m});function C(e,t){const r=e=>t.every((t=>e[t]));return Array.isArray(e)?e.every((e=>r(e))):r(e)}const w=(e,t)=>t.reduce(((t,r)=>e[r]?t:`${t.length?`${t},`:""}${r.toString()}`),""),D=e("tsdav:collection"),b=async e=>{const{url:t,body:r,depth:a,defaultNamespace:o=s.DAV,headers:n,headersToExclude:c,fetchOptions:d={}}=e,i=await v({url:t,init:{method:"REPORT",headers:h(l({depth:a,...n}),c),namespace:o,body:r},fetchOptions:d});return 1!==i.length||i[0].raw?i:[]},V=async e=>{const{url:t,props:r,depth:a,headers:o,headersToExclude:n,fetchOptions:c={}}=e;return v({url:t,init:{method:"MKCOL",headers:h(l({depth:a,...o}),n),namespace:s.DAV,body:r?{mkcol:{set:{prop:r}}}:void 0},fetchOptions:c})},$=async e=>{var t,r,a,o,n;const{collection:c,headers:d,headersToExclude:i,fetchOptions:l={}}=e;return null!==(n=null===(o=null===(a=null===(r=null===(t=(await y({url:c.url,props:{[`${s.DAV}:supported-report-set`]:{}},depth:"0",headers:h(d,i),fetchOptions:l}))[0])||void 0===t?void 0:t.props)||void 0===r?void 0:r.supportedReportSet)||void 0===a?void 0:a.supportedReport)||void 0===o?void 0:o.map((e=>Object.keys(e.report)[0])))&&void 0!==n?n:[]},E=async e=>{var t,r,a;const{collection:o,headers:n,headersToExclude:c,fetchOptions:i={}}=e,l=(await y({url:o.url,props:{[`${s.CALENDAR_SERVER}:getctag`]:{}},depth:"0",headers:h(n,c),fetchOptions:i})).filter((e=>d(o.url,e.href)))[0];if(!l)throw new Error("Collection does not exist on server");return{isDirty:`${o.ctag}`!=`${null===(t=l.props)||void 0===t?void 0:t.getctag}`,newCtag:null===(a=null===(r=l.props)||void 0===r?void 0:r.getctag)||void 0===a?void 0:a.toString()}},T=e=>{const{url:t,props:a,headers:o,syncLevel:n,syncToken:c,headersToExclude:d,fetchOptions:l}=e;return v({url:t,init:{method:"REPORT",namespace:s.DAV,headers:h({...o},d),body:{"sync-collection":{_attributes:i([r.CALDAV,r.CARDDAV,r.DAV]),"sync-level":n,"sync-token":c,[`${s.DAV}:prop`]:a}}},fetchOptions:l})},k=async e=>{var t,r,a,o,n,c,i,l,u,p,f;const{collection:v,method:y,headers:O,headersToExclude:m,account:A,detailedResult:g,fetchOptions:b={}}=e,V=["accountType","homeUrl"];if(!A||!C(A,V)){if(!A)throw new Error("no account for smartCollectionSync");throw new Error(`account must have ${w(A,V)} before smartCollectionSync`)}const $=null!=y?y:(null===(t=v.reports)||void 0===t?void 0:t.includes("syncCollection"))?"webdav":"basic";if(D(`smart collection sync with type ${A.accountType} and method ${$}`),"webdav"===$){const e=await T({url:v.url,props:{[`${s.DAV}:getetag`]:{},[`${"caldav"===A.accountType?s.CALDAV:s.CARDDAV}:${"caldav"===A.accountType?"calendar-data":"address-data"}`]:{},[`${s.DAV}:displayname`]:{}},syncLevel:1,syncToken:v.syncToken,headers:h(O,m),fetchOptions:b}),t=e.filter((e=>{var t;const r="caldav"===A.accountType?".ics":".vcf";return(null===(t=e.href)||void 0===t?void 0:t.slice(-4))===r})),u=t.filter((e=>404!==e.status)).map((e=>e.href)),p=t.filter((e=>404===e.status)).map((e=>e.href)),f=(u.length&&null!==(a=await(null===(r=null==v?void 0:v.objectMultiGet)||void 0===r?void 0:r.call(v,{url:v.url,props:{[`${s.DAV}:getetag`]:{},[`${"caldav"===A.accountType?s.CALDAV:s.CARDDAV}:${"caldav"===A.accountType?"calendar-data":"address-data"}`]:{}},objectUrls:u,depth:"1",headers:h(O,m),fetchOptions:b})))&&void 0!==a?a:[]).map((e=>{var t,r,a,s,o,n,c,d,i,l;return{url:null!==(t=e.href)&&void 0!==t?t:"",etag:null===(r=e.props)||void 0===r?void 0:r.getetag,data:"caldav"===(null==A?void 0:A.accountType)?null!==(o=null===(s=null===(a=e.props)||void 0===a?void 0:a.calendarData)||void 0===s?void 0:s._cdata)&&void 0!==o?o:null===(n=e.props)||void 0===n?void 0:n.calendarData:null!==(i=null===(d=null===(c=e.props)||void 0===c?void 0:c.addressData)||void 0===d?void 0:d._cdata)&&void 0!==i?i:null===(l=e.props)||void 0===l?void 0:l.addressData}})),y=null!==(o=v.objects)&&void 0!==o?o:[],C=f.filter((e=>y.every((t=>!d(t.url,e.url))))),w=y.reduce(((e,t)=>{const r=f.find((e=>d(e.url,t.url)));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e}),[]),D=p.map((e=>({url:e,etag:""}))),V=y.filter((e=>f.some((t=>d(e.url,t.url)&&t.etag===e.etag))));return{...v,objects:g?{created:C,updated:w,deleted:D}:[...V,...C,...w],syncToken:null!==(l=null===(i=null===(c=null===(n=e[0])||void 0===n?void 0:n.raw)||void 0===c?void 0:c.multistatus)||void 0===i?void 0:i.syncToken)&&void 0!==l?l:v.syncToken}}if("basic"===$){const{isDirty:e,newCtag:t}=await E({collection:v,headers:h(O,m),fetchOptions:b}),r=null!==(u=v.objects)&&void 0!==u?u:[],a=null!==(f=await(null===(p=v.fetchObjects)||void 0===p?void 0:p.call(v,{collection:v,headers:h(O,m),fetchOptions:b})))&&void 0!==f?f:[],s=a.filter((e=>r.every((t=>!d(t.url,e.url))))),o=r.reduce(((e,t)=>{const r=a.find((e=>d(e.url,t.url)));return r&&r.etag&&r.etag!==t.etag?[...e,r]:e}),[]),n=r.filter((e=>a.every((t=>!d(t.url,e.url))))),c=r.filter((e=>a.some((t=>d(e.url,t.url)&&t.etag===e.etag))));if(e)return{...v,objects:g?{created:s,updated:o,deleted:n}:[...c,...s,...o],ctag:t}}return g?{...v,objects:{created:[],updated:[],deleted:[]}}:v};var U=Object.freeze({__proto__:null,collectionQuery:b,isCollectionDirty:E,makeCollection:V,smartCollectionSync:k,supportedReportSet:$,syncCollection:T});const _=e("tsdav:addressBook"),R=async e=>{const{url:t,props:a,filters:o,depth:n,headers:c,headersToExclude:d,fetchOptions:u={}}=e;return b({url:t,body:{"addressbook-query":l({_attributes:i([r.CARDDAV,r.DAV]),[`${s.DAV}:prop`]:a,filter:null!=o?o:{"prop-filter":{_attributes:{name:"FN"}}}})},defaultNamespace:s.CARDDAV,depth:n,headers:h(c,d),fetchOptions:u})},L=async e=>{const{url:t,props:a,objectUrls:o,depth:n,headers:c,headersToExclude:d,fetchOptions:u={}}=e;return b({url:t,body:{"addressbook-multiget":l({_attributes:i([r.DAV,r.CARDDAV]),[`${s.DAV}:prop`]:a,[`${s.DAV}:href`]:o})},defaultNamespace:s.CARDDAV,depth:n,headers:h(c,d),fetchOptions:u})},j=async e=>{const{account:t,headers:r,props:a,headersToExclude:o,fetchOptions:n={}}=null!=e?e:{},c=["homeUrl","rootUrl"];if(!t||!C(t,c)){if(!t)throw new Error("no account for fetchAddressBooks");throw new Error(`account must have ${w(t,c)} before fetchAddressBooks`)}const d=await y({url:t.homeUrl,props:null!=a?a:{[`${s.DAV}:displayname`]:{},[`${s.CALENDAR_SERVER}:getctag`]:{},[`${s.DAV}:resourcetype`]:{},[`${s.DAV}:sync-token`]:{}},depth:"1",headers:h(r,o),fetchOptions:n});return Promise.all(d.filter((e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("addressbook")})).map((e=>{var r,a,s,o,n,c,d,i,l;const u=null!==(s=null===(a=null===(r=e.props)||void 0===r?void 0:r.displayname)||void 0===a?void 0:a._cdata)&&void 0!==s?s:null===(o=e.props)||void 0===o?void 0:o.displayname;return _(`Found address book named ${"string"==typeof u?u:""},\n             props: ${JSON.stringify(e.props)}`),{url:new URL(null!==(n=e.href)&&void 0!==n?n:"",null!==(c=t.rootUrl)&&void 0!==c?c:"").href,ctag:null===(d=e.props)||void 0===d?void 0:d.getctag,displayName:"string"==typeof u?u:"",resourcetype:Object.keys(null===(i=e.props)||void 0===i?void 0:i.resourcetype),syncToken:null===(l=e.props)||void 0===l?void 0:l.syncToken}})).map((async e=>({...e,reports:await $({collection:e,headers:h(r,o),fetchOptions:n})}))))},x=async e=>{const{addressBook:t,headers:r,objectUrls:a,headersToExclude:o,urlFilter:n=e=>e,useMultiGet:c=!0,fetchOptions:d={}}=e;_(`Fetching vcards from ${null==t?void 0:t.url}`);const i=["url"];if(!t||!C(t,i)){if(!t)throw new Error("cannot fetchVCards for undefined addressBook");throw new Error(`addressBook must have ${w(t,i)} before fetchVCards`)}const l=(null!=a?a:(await R({url:t.url,props:{[`${s.DAV}:getetag`]:{}},depth:"1",headers:h(r,o),fetchOptions:d})).map((e=>{var t;return e.ok&&null!==(t=e.href)&&void 0!==t?t:""}))).map((e=>e.startsWith("http")||!e?e:new URL(e,t.url).href)).filter(n).map((e=>new URL(e).pathname));let u=[];return l.length>0&&(u=c?await L({url:t.url,props:{[`${s.DAV}:getetag`]:{},[`${s.CARDDAV}:address-data`]:{}},objectUrls:l,depth:"1",headers:h(r,o),fetchOptions:d}):await R({url:t.url,props:{[`${s.DAV}:getetag`]:{},[`${s.CARDDAV}:address-data`]:{}},depth:"1",headers:h(r,o),fetchOptions:d})),u.map((e=>{var r,a,s,o,n,c;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:null===(a=e.props)||void 0===a?void 0:a.getetag,data:null!==(n=null===(o=null===(s=e.props)||void 0===s?void 0:s.addressData)||void 0===o?void 0:o._cdata)&&void 0!==n?n:null===(c=e.props)||void 0===c?void 0:c.addressData}}))},S=async e=>{const{addressBook:t,vCardString:r,filename:a,headers:s,headersToExclude:o,fetchOptions:n={}}=e;return O({url:new URL(a,t.url).href,data:r,headers:h({"content-type":"text/vcard; charset=utf-8","If-None-Match":"*",...s},o),fetchOptions:n})},N=async e=>{const{vCard:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return m({url:t.url,data:t.data,etag:t.etag,headers:h({"content-type":"text/vcard; charset=utf-8",...r},a),fetchOptions:s})},H=async e=>{const{vCard:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return A({url:t.url,etag:t.etag,headers:h(r,a),fetchOptions:s})};var P=Object.freeze({__proto__:null,addressBookMultiGet:L,addressBookQuery:R,createVCard:S,deleteVCard:H,fetchAddressBooks:j,fetchVCards:x,updateVCard:N});const B=e("tsdav:calendar"),F=async e=>{var t,r,a;const{account:o,headers:n,headersToExclude:c,fetchOptions:i={}}=e,l=["principalUrl","rootUrl"];if(!C(o,l))throw new Error(`account must have ${w(o,l)} before fetchUserAddresses`);B(`Fetch user addresses from ${o.principalUrl}`);const u=(await y({url:o.principalUrl,props:{[`${s.CALDAV}:calendar-user-address-set`]:{}},depth:"0",headers:h(n,c),fetchOptions:i})).find((e=>d(o.principalUrl,e.href)));if(!u||!u.ok)throw new Error("cannot find calendarUserAddresses");const p=(null===(a=null===(r=null===(t=null==u?void 0:u.props)||void 0===t?void 0:t.calendarUserAddressSet)||void 0===r?void 0:r.href)||void 0===a?void 0:a.filter(Boolean))||[];return B(`Fetched calendar user addresses ${p}`),p},I=async e=>{const{url:t,props:a,filters:o,timezone:n,depth:c,headers:d,headersToExclude:u,fetchOptions:p={}}=e;return b({url:t,body:{"calendar-query":l({_attributes:i([r.CALDAV,r.CALENDAR_SERVER,r.CALDAV_APPLE,r.DAV]),[`${s.DAV}:prop`]:a,filter:o,timezone:n})},defaultNamespace:s.CALDAV,depth:c,headers:h(d,u),fetchOptions:p})},M=async e=>{const{url:t,props:a,objectUrls:o,filters:n,timezone:c,depth:d,headers:u,headersToExclude:p,fetchOptions:f={}}=e;return b({url:t,body:{"calendar-multiget":l({_attributes:i([r.DAV,r.CALDAV]),[`${s.DAV}:prop`]:a,[`${s.DAV}:href`]:o,filter:n,timezone:c})},defaultNamespace:s.CALDAV,depth:d,headers:h(u,p),fetchOptions:f})},z=async e=>{const{url:t,props:a,depth:o,headers:n,headersToExclude:c,fetchOptions:d={}}=e;return v({url:t,init:{method:"MKCALENDAR",headers:h(l({depth:o,...n}),c),namespace:s.DAV,body:{[`${s.CALDAV}:mkcalendar`]:{_attributes:i([r.DAV,r.CALDAV,r.CALDAV_APPLE]),set:{prop:a}}}},fetchOptions:d})},Z=async e=>{const{headers:t,account:r,props:a,projectedProps:n,headersToExclude:c,fetchOptions:d={}}=null!=e?e:{},i=["homeUrl","rootUrl"];if(!r||!C(r,i)){if(!r)throw new Error("no account for fetchCalendars");throw new Error(`account must have ${w(r,i)} before fetchCalendars`)}const l=await y({url:r.homeUrl,props:null!=a?a:{[`${s.CALDAV}:calendar-description`]:{},[`${s.CALDAV}:calendar-timezone`]:{},[`${s.DAV}:displayname`]:{},[`${s.CALDAV_APPLE}:calendar-color`]:{},[`${s.CALENDAR_SERVER}:getctag`]:{},[`${s.DAV}:resourcetype`]:{},[`${s.CALDAV}:supported-calendar-component-set`]:{},[`${s.DAV}:sync-token`]:{}},depth:"1",headers:h(t,c),fetchOptions:d});return Promise.all(l.filter((e=>{var t,r;return Object.keys(null!==(r=null===(t=e.props)||void 0===t?void 0:t.resourcetype)&&void 0!==r?r:{}).includes("calendar")})).filter((e=>{var t,r,a,s,n,c;return(Array.isArray(null===(r=null===(t=e.props)||void 0===t?void 0:t.supportedCalendarComponentSet)||void 0===r?void 0:r.comp)?null===(a=e.props)||void 0===a?void 0:a.supportedCalendarComponentSet.comp.map((e=>e._attributes.name)):[null===(c=null===(n=null===(s=e.props)||void 0===s?void 0:s.supportedCalendarComponentSet)||void 0===n?void 0:n.comp)||void 0===c?void 0:c._attributes.name]).some((e=>Object.values(o).includes(e)))})).map((e=>{var t,a,s,o,c,d,i,l,h,p,f,v,y,O,m,A;const g=null===(t=e.props)||void 0===t?void 0:t.calendarDescription,C=null===(a=e.props)||void 0===a?void 0:a.calendarTimezone;return{description:"string"==typeof g?g:"",timezone:"string"==typeof C?C:"",url:new URL(null!==(s=e.href)&&void 0!==s?s:"",null!==(o=r.rootUrl)&&void 0!==o?o:"").href,ctag:null===(c=e.props)||void 0===c?void 0:c.getctag,calendarColor:null===(d=e.props)||void 0===d?void 0:d.calendarColor,displayName:null!==(l=null===(i=e.props)||void 0===i?void 0:i.displayname._cdata)&&void 0!==l?l:null===(h=e.props)||void 0===h?void 0:h.displayname,components:Array.isArray(null===(p=e.props)||void 0===p?void 0:p.supportedCalendarComponentSet.comp)?null===(f=e.props)||void 0===f?void 0:f.supportedCalendarComponentSet.comp.map((e=>e._attributes.name)):[null===(y=null===(v=e.props)||void 0===v?void 0:v.supportedCalendarComponentSet.comp)||void 0===y?void 0:y._attributes.name],resourcetype:Object.keys(null===(O=e.props)||void 0===O?void 0:O.resourcetype),syncToken:null===(m=e.props)||void 0===m?void 0:m.syncToken,...u("projectedProps",Object.fromEntries(Object.entries(null!==(A=e.props)&&void 0!==A?A:{}).filter((([e])=>null==n?void 0:n[e]))))}})).map((async e=>({...e,reports:await $({collection:e,headers:h(t,c),fetchOptions:d})}))))},G=async e=>{const{calendar:t,objectUrls:r,filters:a,timeRange:o,headers:n,expand:c,urlFilter:d=e=>Boolean(null==e?void 0:e.includes(".ics")),useMultiGet:i=!0,headersToExclude:l,fetchOptions:u={}}=e;if(o){const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(o.start)&&e.test(o.end)||t.test(o.start)&&t.test(o.end)))throw new Error("invalid timeRange format, not in ISO8601")}B(`Fetching calendar objects from ${null==t?void 0:t.url}`);const p=["url"];if(!t||!C(t,p)){if(!t)throw new Error("cannot fetchCalendarObjects for undefined calendar");throw new Error(`calendar must have ${w(t,p)} before fetchCalendarObjects`)}const f=null!=a?a:[{"comp-filter":{_attributes:{name:"VCALENDAR"},"comp-filter":{_attributes:{name:"VEVENT"},...o?{"time-range":{_attributes:{start:`${new Date(o.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(o.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}}}],v=(null!=r?r:(await I({url:t.url,props:{[`${s.DAV}:getetag`]:{...c&&o?{[`${s.CALDAV}:expand`]:{_attributes:{start:`${new Date(o.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(o.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:f,depth:"1",headers:h(n,l),fetchOptions:u})).map((e=>{var t;return null!==(t=e.href)&&void 0!==t?t:""}))).map((e=>e.startsWith("http")||!e?e:new URL(e,t.url).href)).filter(d).map((e=>new URL(e).pathname));let y=[];return v.length>0&&(y=!i||c?await I({url:t.url,props:{[`${s.DAV}:getetag`]:{},[`${s.CALDAV}:calendar-data`]:{...c&&o?{[`${s.CALDAV}:expand`]:{_attributes:{start:`${new Date(o.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(o.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},filters:f,depth:"1",headers:h(n,l),fetchOptions:u}):await M({url:t.url,props:{[`${s.DAV}:getetag`]:{},[`${s.CALDAV}:calendar-data`]:{...c&&o?{[`${s.CALDAV}:expand`]:{_attributes:{start:`${new Date(o.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(o.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}}:{}}},objectUrls:v,depth:"1",headers:h(n,l),fetchOptions:u})),y.map((e=>{var r,a,s,o,n,c;return{url:new URL(null!==(r=e.href)&&void 0!==r?r:"",t.url).href,etag:`${null===(a=e.props)||void 0===a?void 0:a.getetag}`,data:null!==(n=null===(o=null===(s=e.props)||void 0===s?void 0:s.calendarData)||void 0===o?void 0:o._cdata)&&void 0!==n?n:null===(c=e.props)||void 0===c?void 0:c.calendarData}}))},Q=async e=>{const{calendar:t,iCalString:r,filename:a,headers:s,headersToExclude:o,fetchOptions:n={}}=e;return O({url:new URL(a,t.url).href,data:r,headers:h({"content-type":"text/calendar; charset=utf-8","If-None-Match":"*",...s},o),fetchOptions:n})},q=async e=>{const{calendarObject:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return m({url:t.url,data:t.data,etag:t.etag,headers:h({"content-type":"text/calendar; charset=utf-8",...r},a),fetchOptions:s})},J=async e=>{const{calendarObject:t,headers:r,headersToExclude:a,fetchOptions:s={}}=e;return A({url:t.url,etag:t.etag,headers:h(r,a),fetchOptions:s})},K=async e=>{var t;const{oldCalendars:r,account:a,detailedResult:s,headers:o,headersToExclude:n,fetchOptions:c={}}=e;if(!a)throw new Error("Must have account before syncCalendars");const i=null!==(t=null!=r?r:a.calendars)&&void 0!==t?t:[],l=await Z({account:a,headers:h(o,n),fetchOptions:c}),u=l.filter((e=>i.every((t=>!d(t.url,e.url)))));B(`new calendars: ${u.map((e=>e.displayName))}`);const p=i.reduce(((e,t)=>{const r=l.find((e=>d(e.url,t.url)));return r&&(r.syncToken&&`${r.syncToken}`!=`${t.syncToken}`||r.ctag&&`${r.ctag}`!=`${t.ctag}`)?[...e,r]:e}),[]);B(`updated calendars: ${p.map((e=>e.displayName))}`);const f=await Promise.all(p.map((async e=>await k({collection:{...e,objectMultiGet:M},method:"webdav",headers:h(o,n),account:a,fetchOptions:c})))),v=i.filter((e=>l.every((t=>!d(t.url,e.url)))));B(`deleted calendars: ${v.map((e=>e.displayName))}`);const y=i.filter((e=>l.some((t=>d(t.url,e.url)&&(t.syncToken&&`${t.syncToken}`!=`${e.syncToken}`||t.ctag&&`${t.ctag}`!=`${e.ctag}`)))));return s?{created:u,updated:p,deleted:v}:[...y,...u,...f]},W=async e=>{const{url:t,timeRange:a,depth:o,headers:n,headersToExclude:c,fetchOptions:d={}}=e;if(!a)throw new Error("timeRange is required");{const e=/^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?)?)?)?$/i,t=/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;if(!(e.test(a.start)&&e.test(a.end)||t.test(a.start)&&t.test(a.end)))throw new Error("invalid timeRange format, not in ISO8601")}return(await b({url:t,body:{"free-busy-query":l({_attributes:i([r.CALDAV]),[`${s.CALDAV}:time-range`]:{_attributes:{start:`${new Date(a.start).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`,end:`${new Date(a.end).toISOString().slice(0,19).replace(/[-:.]/g,"")}Z`}}})},defaultNamespace:s.CALDAV,depth:o,headers:h(n,c),fetchOptions:d}))[0]};var Y=Object.freeze({__proto__:null,calendarMultiGet:M,calendarQuery:I,createCalendarObject:Q,deleteCalendarObject:J,fetchCalendarObjects:G,fetchCalendarUserAddresses:F,fetchCalendars:Z,freeBusyQuery:W,makeCalendar:z,syncCalendars:K,updateCalendarObject:q});const X=e("tsdav:account"),ee=async e=>{var t,r;X("Service discovery...");const{account:a,headers:s,headersToExclude:o,fetchOptions:n={}}=e,c=new URL(a.serverUrl),d=new URL(`/.well-known/${a.accountType}`,c);d.protocol=null!==(t=c.protocol)&&void 0!==t?t:"http";try{const e=await fetch(d.href,{headers:h(s,o),method:"PROPFIND",redirect:"manual",...n});if(e.status>=300&&e.status<400){const t=e.headers.get("Location");if("string"==typeof t&&t.length){X(`Service discovery redirected to ${t}`);const e=new URL(t,c);return e.hostname===d.hostname&&d.port&&!e.port&&(e.port=d.port),e.protocol=null!==(r=c.protocol)&&void 0!==r?r:"http",e.href}}}catch(e){X(`Service discovery failed: ${e.stack}`)}return c.href},te=async e=>{var t,r,a,o,n;const{account:c,headers:d,headersToExclude:i,fetchOptions:l={}}=e,u=["rootUrl"];if(!C(c,u))throw new Error(`account must have ${w(c,u)} before fetchPrincipalUrl`);X(`Fetching principal url from path ${c.rootUrl}`);const[p]=await y({url:c.rootUrl,props:{[`${s.DAV}:current-user-principal`]:{}},depth:"0",headers:h(d,i),fetchOptions:l});if(!p.ok&&(X(`Fetch principal url failed: ${p.statusText}`),401===p.status))throw new Error("Invalid credentials");return X(`Fetched principal url ${null===(r=null===(t=p.props)||void 0===t?void 0:t.currentUserPrincipal)||void 0===r?void 0:r.href}`),new URL(null!==(n=null===(o=null===(a=p.props)||void 0===a?void 0:a.currentUserPrincipal)||void 0===o?void 0:o.href)&&void 0!==n?n:"",c.rootUrl).href},re=async e=>{var t,r;const{account:a,headers:o,headersToExclude:n,fetchOptions:c={}}=e,i=["principalUrl","rootUrl"];if(!C(a,i))throw new Error(`account must have ${w(a,i)} before fetchHomeUrl`);X(`Fetch home url from ${a.principalUrl}`);const l=(await y({url:a.principalUrl,props:"caldav"===a.accountType?{[`${s.CALDAV}:calendar-home-set`]:{}}:{[`${s.CARDDAV}:addressbook-home-set`]:{}},depth:"0",headers:h(o,n),fetchOptions:c})).find((e=>d(a.principalUrl,e.href)));if(!l||!l.ok)throw new Error("cannot find homeUrl");const u=new URL("caldav"===a.accountType?null===(t=null==l?void 0:l.props)||void 0===t?void 0:t.calendarHomeSet.href:null===(r=null==l?void 0:l.props)||void 0===r?void 0:r.addressbookHomeSet.href,a.rootUrl).href;return X(`Fetched home url ${u}`),u},ae=async e=>{const{account:t,headers:r,loadCollections:a=!1,loadObjects:s=!1,headersToExclude:o,fetchOptions:n={}}=e,c={...t};return c.rootUrl=await ee({account:t,headers:h(r,o),fetchOptions:n}),c.principalUrl=await te({account:c,headers:h(r,o),fetchOptions:n}),c.homeUrl=await re({account:c,headers:h(r,o),fetchOptions:n}),(a||s)&&("caldav"===t.accountType?c.calendars=await Z({headers:h(r,o),account:c,fetchOptions:n}):"carddav"===t.accountType&&(c.addressBooks=await j({headers:h(r,o),account:c,fetchOptions:n}))),s&&("caldav"===t.accountType&&c.calendars?c.calendars=await Promise.all(c.calendars.map((async e=>({...e,objects:await G({calendar:e,headers:h(r,o),fetchOptions:n})})))):"carddav"===t.accountType&&c.addressBooks&&(c.addressBooks=await Promise.all(c.addressBooks.map((async e=>({...e,objects:await x({addressBook:e,headers:h(r,o),fetchOptions:n})})))))),c};var se=Object.freeze({__proto__:null,createAccount:ae,fetchHomeUrl:re,fetchPrincipalUrl:te,serviceDiscovery:ee});const oe=e("tsdav:authHelper"),ne=(e,t)=>(...r)=>e({...t,...r[0]}),ce=e=>(oe(`Basic auth token generated: ${btoa(`${e.username}:${e.password}`)}`),{authorization:`Basic ${btoa(`${e.username}:${e.password}`)}`}),de=async(e,t)=>{const r=["authorizationCode","redirectUrl","clientId","clientSecret","tokenUrl"];if(!C(e,r))throw new Error(`Oauth credentials missing: ${w(e,r)}`);const a=new URLSearchParams({grant_type:"authorization_code",code:e.authorizationCode,redirect_uri:e.redirectUrl,client_id:e.clientId,client_secret:e.clientSecret});oe(e.tokenUrl),oe(a.toString());const s=await fetch(e.tokenUrl,{method:"POST",body:a.toString(),headers:{"content-length":`${a.toString().length}`,"content-type":"application/x-www-form-urlencoded"},...null!=t?t:{}});if(s.ok){return await s.json()}return oe(`Fetch Oauth tokens failed: ${await s.text()}`),{}},ie=async(e,t)=>{const r=["refreshToken","clientId","clientSecret","tokenUrl"];if(!C(e,r))throw new Error(`Oauth credentials missing: ${w(e,r)}`);const a=new URLSearchParams({client_id:e.clientId,client_secret:e.clientSecret,refresh_token:e.refreshToken,grant_type:"refresh_token"}),s=await fetch(e.tokenUrl,{method:"POST",body:a.toString(),headers:{"Content-Type":"application/x-www-form-urlencoded"},...null!=t?t:{}});if(s.ok){return await s.json()}return oe(`Refresh access token failed: ${await s.text()}`),{}},le=async(e,t)=>{var r;oe("Fetching oauth headers");let a={};return e.refreshToken?(e.refreshToken&&!e.accessToken||Date.now()>(null!==(r=e.expiration)&&void 0!==r?r:0))&&(a=await ie(e,t)):a=await de(e,t),oe(`Oauth tokens fetched: ${a.access_token}`),{tokens:a,headers:{authorization:`Bearer ${a.access_token}`}}};var ue=Object.freeze({__proto__:null,defaultParam:ne,fetchOauthTokens:de,getBasicAuthHeaders:ce,getOauthHeaders:le,refreshAccessToken:ie});const he=async e=>{var t;const{serverUrl:r,credentials:a,authMethod:s,defaultAccountType:o,authFunction:n}=e;let c={};switch(s){case"Basic":c=ce(a);break;case"Oauth":c=(await le(a)).headers;break;case"Digest":c={Authorization:`Digest ${a.digestString}`};break;case"Custom":c=null!==(t=await(null==n?void 0:n(a)))&&void 0!==t?t:{};break;default:throw new Error("Invalid auth method")}const d=o?await ae({account:{serverUrl:r,credentials:a,accountType:o},headers:c}):void 0,i=ne(O,{url:r,headers:c}),l=ne(m,{headers:c,url:r}),u=ne(A,{headers:c,url:r}),h=ne(y,{headers:c}),p=ne(b,{headers:c}),f=ne(V,{headers:c}),g=ne(T,{headers:c}),C=ne($,{headers:c}),w=ne(E,{headers:c}),D=ne(k,{headers:c,account:d}),U=ne(I,{headers:c}),_=ne(M,{headers:c}),P=ne(z,{headers:c}),B=ne(Z,{headers:c,account:d}),W=ne(F,{headers:c,account:d}),Y=ne(G,{headers:c}),X=ne(Q,{headers:c}),ee=ne(q,{headers:c}),te=ne(J,{headers:c}),re=ne(K,{account:d,headers:c}),se=ne(R,{headers:c}),oe=ne(L,{headers:c});return{davRequest:async e=>{const{init:t,...r}=e,{headers:a,...s}=t;return v({...r,init:{...s,headers:{...c,...a}}})},propfind:h,createAccount:async e=>{const{account:t,headers:s,loadCollections:o,loadObjects:n}=e;return ae({account:{serverUrl:r,credentials:a,...t},headers:{...c,...s},loadCollections:o,loadObjects:n})},createObject:i,updateObject:l,deleteObject:u,calendarQuery:U,addressBookQuery:se,collectionQuery:p,makeCollection:f,calendarMultiGet:_,makeCalendar:P,syncCollection:g,supportedReportSet:C,isCollectionDirty:w,smartCollectionSync:D,fetchCalendars:B,fetchCalendarUserAddresses:W,fetchCalendarObjects:Y,createCalendarObject:X,updateCalendarObject:ee,deleteCalendarObject:te,syncCalendars:re,fetchAddressBooks:ne(j,{account:d,headers:c}),addressBookMultiGet:oe,fetchVCards:ne(x,{headers:c}),createVCard:ne(S,{headers:c}),updateVCard:ne(N,{headers:c}),deleteVCard:ne(H,{headers:c})}};class pe{constructor(e){var t,r,a;this.serverUrl=e.serverUrl,this.credentials=e.credentials,this.authMethod=null!==(t=e.authMethod)&&void 0!==t?t:"Basic",this.accountType=null!==(r=e.defaultAccountType)&&void 0!==r?r:"caldav",this.authFunction=e.authFunction,this.fetchOptions=null!==(a=e.fetchOptions)&&void 0!==a?a:{}}async login(){var e;switch(this.authMethod){case"Basic":this.authHeaders=ce(this.credentials);break;case"Oauth":this.authHeaders=(await le(this.credentials,this.fetchOptions)).headers;break;case"Digest":this.authHeaders={Authorization:`Digest ${this.credentials.digestString}`};break;case"Custom":this.authHeaders=await(null===(e=this.authFunction)||void 0===e?void 0:e.call(this,this.credentials));break;default:throw new Error("Invalid auth method")}this.account=this.accountType?await ae({account:{serverUrl:this.serverUrl,credentials:this.credentials,accountType:this.accountType},headers:this.authHeaders,fetchOptions:this.fetchOptions}):void 0}async davRequest(e){const{init:t,...r}=e,{headers:a,...s}=t;return v({...r,init:{...s,headers:{...this.authHeaders,...a}},fetchOptions:this.fetchOptions})}async createObject(...e){return ne(O,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateObject(...e){return ne(m,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteObject(...e){return ne(A,{url:this.serverUrl,headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async propfind(...e){return ne(y,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createAccount(e){const{account:t,headers:r,loadCollections:a,loadObjects:s,fetchOptions:o}=e;return ae({account:{serverUrl:this.serverUrl,credentials:this.credentials,...t},headers:{...this.authHeaders,...r},loadCollections:a,loadObjects:s,fetchOptions:null!=o?o:this.fetchOptions})}async collectionQuery(...e){return ne(b,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async makeCollection(...e){return ne(V,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async syncCollection(...e){return ne(T,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async supportedReportSet(...e){return ne($,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async isCollectionDirty(...e){return ne(E,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async smartCollectionSync(...e){return ne(k,{headers:this.authHeaders,fetchOptions:this.fetchOptions,account:this.account})(e[0])}async calendarQuery(...e){return ne(I,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async makeCalendar(...e){return ne(z,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async calendarMultiGet(...e){return ne(M,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async fetchCalendars(...e){return ne(Z,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchCalendarUserAddresses(...e){return ne(F,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchCalendarObjects(...e){return ne(G,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createCalendarObject(...e){return ne(Q,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateCalendarObject(...e){return ne(q,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteCalendarObject(...e){return ne(J,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async syncCalendars(...e){return ne(K,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(e[0])}async addressBookQuery(...e){return ne(R,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async addressBookMultiGet(...e){return ne(L,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async fetchAddressBooks(...e){return ne(j,{headers:this.authHeaders,account:this.account,fetchOptions:this.fetchOptions})(null==e?void 0:e[0])}async fetchVCards(...e){return ne(x,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async createVCard(...e){return ne(S,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async updateVCard(...e){return ne(N,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}async deleteVCard(...e){return ne(H,{headers:this.authHeaders,fetchOptions:this.fetchOptions})(e[0])}}var fe={DAVNamespace:r,DAVNamespaceShort:s,DAVAttributeMap:a,...Object.freeze({__proto__:null,DAVClient:pe,createDAVClient:he}),...g,...U,...se,...P,...Y,...ue,...p};export{a as DAVAttributeMap,pe as DAVClient,r as DAVNamespace,s as DAVNamespaceShort,L as addressBookMultiGet,R as addressBookQuery,M as calendarMultiGet,I as calendarQuery,l as cleanupFalsy,b as collectionQuery,ae as createAccount,Q as createCalendarObject,he as createDAVClient,O as createObject,S as createVCard,v as davRequest,fe as default,J as deleteCalendarObject,A as deleteObject,H as deleteVCard,j as fetchAddressBooks,G as fetchCalendarObjects,F as fetchCalendarUserAddresses,Z as fetchCalendars,de as fetchOauthTokens,x as fetchVCards,W as freeBusyQuery,ce as getBasicAuthHeaders,i as getDAVAttribute,le as getOauthHeaders,E as isCollectionDirty,z as makeCalendar,y as propfind,ie as refreshAccessToken,k as smartCollectionSync,$ as supportedReportSet,K as syncCalendars,T as syncCollection,q as updateCalendarObject,m as updateObject,N as updateVCard,d as urlContains,c as urlEquals};
